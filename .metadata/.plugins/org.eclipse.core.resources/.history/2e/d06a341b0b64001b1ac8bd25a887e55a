package _java._LEETCODE.Dynamic_Programing;
import java.util.*;

/*
 * Question: https://leetcode.com/problems/count-sorted-vowel-strings/
 * 
 * Response: SOLVED, but needs DP optimization
 * 
 * Optimization: DP approach
 */
public class M1_Count_Sorted_Vowel_Strings {

	static char vow[] = new char[]{'a', 'e', 'i', 'o', 'u'}; 
	static List<String> res;
	static int count =0;
	
	public static void main(String[] args) {
		int n = 33;
		
//		int ans = myApproach(n);
//		System.out.println("MyApproach: 5%, 700ms \n" + ans);
		
		
		int dpAns = optimize(n);
		System.out.println("Optmize: 100%, 0ms O(n) \n" + dpAns);
	}
	
    private static int optimize(int n) {
        int a = 1, e = 1, i = 1, o = 1, u = 1;
        while(n > 1) {
			// add new char before previous string
            a = (a + e + i + o + u); // a, e, i, o, u -> aa, ae, ai, ao, au
            e = (e + i + o + u); // e, i, o, u -> ee, ei, eo, eu
            i = (i + o + u); // i, o, u -> ii, io, iu
            o = (o + u); // o, u -> oo, ou
            u = (u); // u -> uu
            n--;
        }
        
        return a + e + i + o + u;
    }
	public static int myApproach(int n) {
        for(int j=0;j<5; j++)
            solve(n, 1, 0, String.valueOf(vow[j]));
        
        return count;
    }
    
    public static void solve(int n, int i, int j, String word) {
        if(i == n){
            count++;
            return;
        }
        
        if(j>=5)
            return;
        
        if(word.charAt(word.length()-1) <= vow[j]){
            // here, j doesn't change bcoz 
            // this character is added .. and again for next letter
            // we iterate thro same index
            // word = a, new word = aa... for next time again start from  a.. and results word aaa.
            solve(n, i+1, j, word + vow[j]); 
        }
        
        solve(n, i, j+1, word);
    }

}
